#包含yield关键字 就变成了生成器函数
#调用函数并不会执行语句
def foo():
    print('Starting....')
    while True:
        # 序遇到yield关键字，然后把yield想想成return, return了一个4之后，程序停止，
        # 但是，程序只是返回了一个值4，并没有执行将4赋值给res操作，此时next(g)
        # 语句执行完成，
        res = yield 4
        print('yes:', res)


#下面调用函数并没有执行 可以先将后面的语句注释掉
#逐行运行代码 观察效果

#程序开始执行以后，因为foo函数中有yield关键字，所以foo函数并不会真的执行，
# 而是先得到一个生成器g(相当于一个对象)，函数的一个状态，函数相当于暂停了
g = foo()
print('第一次调用执行结果:')
#next()把生成器的对象以参数形式传入
print(next(g))
print('*' * 100)

print('第二次调用执行结果:')
# 行第二次调用，又开始执行下面的print(next(g)),这个时候和上面那个差不多，
# 不过不同的是，这个时候是从刚才那个next程序停止的地方开始执行的，
# 也就是要执行res的赋值操作语句，这时候要注意，yield 4返回值4后就停止了，
# 并没有赋值给前面的res, （因为刚才那个是return出去了，并没有给赋值操作的左边传参数）
# ，此时代码实际是从print(“res:”, res)开始执行，
# 这个时候res赋值是空，是None,所以接着下面的输出就是res:None,

# 这一次的next开始的地方是接着上一次的next停止的地方执行的，
# 所以调用next的时候，生成器并不会从foo函数的开始执行，
# 只是接着上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束。
print(next(g))
print('*'*100)

#for循环执行过程:
#1.调用可迭代对象的__iter__方法返回一个迭代器对象(iterator)
#2.不断调用迭代器的__next__方法返回元素
#3.知道迭代完成后 处理StopIteration异常